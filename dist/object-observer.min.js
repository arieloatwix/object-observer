const e="insert",t="update",o="delete",r="reverse",s="shuffle",n=Symbol("system-observer-key"),p=["path","pathsFrom"],a=function(e){const t={};e.path&&"string"!=typeof e.path?console.error('"path" option, if/when provided, MUST be a non-empty string'):t.path=e.path,e.pathsFrom&&(e.path?console.error('"pathsFrom" option MAY NOT be specified together with "path" option'):"string"!=typeof e.pathsFrom?console.error('"pathsFrom" option, if/when provided, MUST be a non-empty string'):t.pathsFrom=e.pathsFrom);const o=Object.keys(e).filter(e=>p.indexOf(e)<0);return o.length&&console.error(`'${o.join(", ")}' is/are not a valid option/s`),t},c=function(){const e=this[n].observers;if(e.size){let t=arguments.length;if(t)for(;t;)e.delete(arguments[--t]);else e.clear()}},l={revoke:{value:function(){this[n].revoke()}},observe:{value:function(e,t){if("function"!=typeof e)throw new Error("observer parameter MUST be a function");const o=this[n].observers;if(o.has(e))console.info("observer may be bound to an observable only once");else{let r;r=t?a(t):{},o.set(e,r)}}},unobserve:{value:c}},i={observe:{value:function(e,t){if("function"!=typeof e)throw new Error("observer parameter MUST be a function");const o=this[n].observers;if(o.has(e))console.info("observer may be bound to an observable only once");else{let r;r=t?a(t):{},o.set(e,r)}}},unobserve:{value:c}},h=function(e,t){let o,r=e.length;const s=new Array(r);for(Object.defineProperty(s,n,{value:t});r;)o=e[--r],s[r]=o&&"object"==typeof o?y(o,r,t):o;return s},f=function(e,t){const o=Object.keys(e),r={};Object.defineProperty(r,n,{value:t});let s,p,a=o.length;for(;a;)p=e[s=o[--a]],r[s]=p&&"object"==typeof p?y(p,s,t):p;return r},b=function(e,t){let o,r,s,n,p;for(o of e.keys())try{r=e.get(o),s=t,r.path?(n=r.path,s=t.filter(e=>e.path.join(".")===n)):r.pathsFrom&&(p=r.pathsFrom,s=t.filter(e=>e.path.join(".").startsWith(p))),s.length&&o(s)}catch(e){console.error(`failed to deliver changes to listener ${o}`,e)}},u=function(e){const t=[];let o=0,r=0;for(;e.parent;)t[o++]=e.ownKey,e=e.parent;const s=new Array(o);for(;o;)s[r++]=t[--o];return{observers:e.observers,path:s}},y=function(e,t,o){return e&&"object"==typeof e?Array.isArray(e)?new j({target:e,ownKey:t,parent:o}).proxy:e instanceof Date||e instanceof Blob||e instanceof Error?e:new g({target:e,ownKey:t,parent:o}).proxy:e};class v{constructor(e,t){const o=t(e.target,this);null===e.parent?(this.isRevoked=!1,Object.defineProperty(this,"observers",{value:new Map}),Object.defineProperties(o,l)):(this.parent=e.parent,this.ownKey=e.ownKey,Object.defineProperties(o,i)),this.revokable=Proxy.revocable(o,this),this.proxy=this.revokable.proxy,this.target=o}set(o,r,s){let p,a=o[r];if(s===a)return!0;const c=y(s,r,this);if(o[r]=c,a&&"object"==typeof a){const e=a[n];e&&(a=e.revoke())}const l=u(this);return l.observers.size&&(l.path.push(r),p=void 0===a?[{type:e,path:l.path,value:c,object:this.proxy}]:[{type:t,path:l.path,value:c,oldValue:a,object:this.proxy}],b(l.observers,p)),!0}deleteProperty(e,t){let r,s=e[t];if(delete e[t],s&&"object"==typeof s){const e=s[n];e&&(s=e.revoke())}const p=u(this);return p.observers.size&&(p.path.push(t),r=[{type:o,path:p.path,oldValue:s,object:this.proxy}],b(p.observers,r)),!0}}class j extends v{constructor(e){super(e,h)}revoke(){this.revokable.revoke();const e=this.target;let t,o,r=e.length;for(;r;)(t=e[--r])&&"object"==typeof t&&(o=t[n])&&(e[r]=o.revoke());return e}get(p,a){const c={pop:function(e,t){const r=e.length-1;let s=e.pop();if(s&&"object"==typeof s){const e=s[n];e&&(s=e.revoke())}const p=u(t);return p.observers.size&&(p.path.push(r),b(p.observers,[{type:o,path:p.path,oldValue:s,object:t.proxy}])),s},push:function(t,o){let r,s,n,p,a=arguments.length-2;const c=new Array(a),l=t.length;for(r=0;r<a;r++)s=arguments[r+2],c[r]=y(s,l+r,o);const i=Reflect.apply(t.push,t,c),h=u(o);if(h.observers.size){for(n=[],r=l,a=t.length;r<a;r++)(p=h.path.slice(0)).push(r),n[r-l]={type:e,path:p,value:t[r],object:o.proxy};b(h.observers,n)}return i},shift:function(e,t){let r,s,p,a,c,l;for((r=e.shift())&&"object"==typeof r&&(l=r[n])&&(r=l.revoke()),s=0,p=e.length;s<p;s++)(a=e[s])&&"object"==typeof a&&(l=a[n])&&(l.ownKey=s);const i=u(t);return i.observers.size&&(i.path.push(0),c=[{type:o,path:i.path,oldValue:r,object:t.proxy}],b(i.observers,c)),r},unshift:function(t,o){const r=Array.from(arguments);let s;r.splice(0,2),r.forEach((e,t)=>{r[t]=y(e,t,o)});const p=Reflect.apply(t.unshift,t,r);for(let e,o=0,r=t.length;o<r;o++)if((e=t[o])&&"object"==typeof e){const t=e[n];t&&(t.ownKey=o)}const a=u(o);if(a.observers.size){const n=r.length;let p;s=new Array(n);for(let r=0;r<n;r++)(p=a.path.slice(0)).push(r),s[r]={type:e,path:p,value:t[r],object:o.proxy};b(a.observers,s)}return p},reverse:function(e,t){let o,s,p,a;for(e.reverse(),o=0,s=e.length;o<s;o++)if((p=e[o])&&"object"==typeof p){const e=p[n];e&&(e.ownKey=o)}const c=u(t);return c.observers.size&&(a=[{type:r,path:c.path,object:t.proxy}],b(c.observers,a)),t.proxy},sort:function(e,t,o){let r,p,a,c;for(e.sort(o),r=0,p=e.length;r<p;r++)if((a=e[r])&&"object"==typeof a){const e=a[n];e&&(e.ownKey=r)}const l=u(t);return l.observers.size&&(c=[{type:s,path:l.path,object:t.proxy}],b(l.observers,c)),t.proxy},fill:function(o,r){const s=u(r),p=[],a=o.length,c=Array.from(arguments);c.splice(0,2);const l=c.length,i=l<2?0:c[1]<0?a+c[1]:c[1],h=l<3?a:c[2]<0?a+c[2]:c[2],f=o.slice(0);let v,j;Reflect.apply(o.fill,o,c);for(let a,c,l=i;l<h;l++)a=o[l],o[l]=y(a,l,r),f.hasOwnProperty(l)?((c=f[l])&&"object"==typeof c&&(v=c[n])&&(c=v.revoke()),(j=s.path.slice(0)).push(l),p.push({type:t,path:j,value:o[l],oldValue:c,object:r.proxy})):((j=s.path.slice(0)).push(l),p.push({type:e,path:j,value:o[l],object:r.proxy}));return s.observers.size&&b(s.observers,p),r.proxy},splice:function(r,s){const p=u(s),a=[],c=Array.from(arguments),l=r.length;c.splice(0,2);const i=c.length;for(let e,t=2;t<i;t++)e=c[t],c[t]=y(e,t,s);const h=0===i?0:c[0]<0?l+c[0]:c[0],f=i<2?l-h:c[1],v=Math.max(i-2,0),j=Reflect.apply(r.splice,r,c),g=r.length;let d,w,x,k;for(let e,t=0;t<g;t++)(e=r[t])&&"object"==typeof e&&(d=e[n])&&(d.ownKey=t);for(w=0,x=j.length;w<x;w++)(k=j[w])&&"object"==typeof k&&(d=k[n])&&(j[w]=d.revoke());if(p.observers.size){let n,c;for(n=0;n<f;n++)(c=p.path.slice(0)).push(h+n),n<v?a.push({type:t,path:c,value:r[h+n],oldValue:j[n],object:s.proxy}):a.push({type:o,path:c,oldValue:j[n],object:s.proxy});for(;n<v;n++)(c=p.path.slice(0)).push(h+n),a.push({type:e,path:c,value:r[h+n],object:s.proxy});b(p.observers,a)}return j}};return c.hasOwnProperty(a)?c[a].bind(void 0,p,this):p[a]}}class g extends v{constructor(e){super(e,f)}revoke(){this.revokable.revoke();const e=this.target,t=Object.keys(e);let o,r,s,p=t.length;for(;p;)(r=e[o=t[--p]])&&"object"==typeof r&&(s=r[n])&&(e[o]=s.revoke());return e}}class d{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(e){if(e&&"object"==typeof e){if(e[n])return e;if(Array.isArray(e))return new j({target:e,ownKey:null,parent:null}).proxy;if(e instanceof Date||e instanceof Blob||e instanceof Error)throw new Error(`${e} found to be one of non-observable types`);return new g({target:e,ownKey:null,parent:null}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")}static isObservable(e){return!(!e||!e[n])}}Object.freeze(d);export{d as Observable};