const e="insert",t="update",o="delete",r=Symbol("system-observer-key"),n=["path","pathsFrom"],s=function(e){const t={};e.path&&"string"!=typeof e.path?console.error('"path" option, if/when provided, MUST be a non-empty string'):t.path=e.path,e.pathsFrom&&(e.path?console.error('"pathsFrom" option MAY NOT be specified together with "path" option'):"string"!=typeof e.pathsFrom?console.error('"pathsFrom" option, if/when provided, MUST be a non-empty string'):t.pathsFrom=e.pathsFrom);const o=Object.keys(e).filter(e=>n.indexOf(e)<0);return o.length&&console.error(`'${o.join(", ")}' is/are not a valid option/s`),t},p=function(){const e=this[r],t=f(e).observers;let o=t.length;if(o){let r=arguments.length;if(r)for(;r--;){let e=o;for(;e--;)t[e][0]===arguments[r]&&(t.splice(e,1),o--)}else for(;o--;)t[o][1].context===e&&t.splice(o,1)}},a={[r]:{writable:!0},detach:{value:function(){this[r].detach()}},observe:{value:function(e,t){if("function"!=typeof e)throw new Error("observer parameter MUST be a function");const o=this[r],n=o.observers;if(n.some(t=>t[0]===e))console.info("observer may be bound to an observable only once");else{let r;(r=t?s(t):{}).context=o,n.push([e,r])}}},unobserve:{value:p}},c={[r]:{writable:!0},observe:{value:function(e,t){if("function"!=typeof e)throw new Error("observer parameter MUST be a function");const o=this[r],n=f(o),p=n.path.join("."),a=n.observers;if(a.some(t=>t[0]===e))console.info("observer may be bound to an observable only once");else{let r;(r=t?s(t):{}).path?r.path=p+"."+r.path:r.pathsFrom=p+"."+(r.pathsFrom?r.pathsFrom:""),r.context=o,a.push([e,r])}}},unobserve:{value:p}},h=function(e,t,o){let n,s=e.length;const p=Object.defineProperties(new Array(s),t);for(p[r]=o;s--;)n=e[s],p[s]=n&&"object"==typeof n?b(n,s,o):n;return p},l=function(e,t,o){const n=Object.keys(e),s=Object.defineProperties({},t);s[r]=o;let p,a,c=n.length;for(;c--;)a=e[p=n[c]],s[p]=a&&"object"==typeof a?b(a,p,o):a;return s},i=function(e,t){let o,r,n,s,p,a,c=e.length;for(;c--;)try{r=(o=e[c])[0],n=o[1],s=t,n.path?(p=n.path,s=t.filter(e=>e.path.join(".")===p)):n.pathsFrom&&(a=n.pathsFrom,s=t.filter(e=>e.path.join(".").startsWith(a))),s.length&&r(s)}catch(e){console.error(`failed to deliver changes to listener ${r}`,e)}},f=function(e){const t=[];let o=0,r=0;for(;e.parent;)t[o++]=e.ownKey,e=e.parent;const n=new Array(o);for(;o--;)n[r++]=t[o];return{observers:e.observers,path:n}},b=function(e,t,o){return e&&"object"==typeof e?Array.isArray(e)?new v({target:e,ownKey:t,parent:o}).proxy:e instanceof Date||e instanceof Blob||e instanceof Error?e:new g({target:e,ownKey:t,parent:o}).proxy:e},u={pop:function(e,t){const n=e.length-1;let s=e.pop();if(s&&"object"==typeof s){const e=s[r];e&&(s=e.detach())}const p=f(t);return p.observers.length&&(p.path.push(n),i(p.observers,[{type:o,path:p.path,oldValue:s,object:t.proxy}])),s},push:function(t,o){let r,n,s,p,a=arguments.length-2;const c=new Array(a),h=t.length;for(r=0;r<a;r++)n=arguments[r+2],c[r]=b(n,h+r,o);const l=Reflect.apply(t.push,t,c),u=f(o);if(u.observers.length){for(s=[],r=h,a=t.length;r<a;r++)(p=u.path.slice(0)).push(r),s[r-h]={type:e,path:p,value:t[r],object:o.proxy};i(u.observers,s)}return l},shift:function(e,t){let n,s,p,a,c;for((n=e.shift())&&"object"==typeof n&&(c=n[r])&&(n=c.detach()),s=0,p=e.length;s<p;s++)(a=e[s])&&"object"==typeof a&&(c=a[r])&&(c.ownKey=s);const h=f(t);return h.observers.length&&(h.path.push(0),i(h.observers,[{type:o,path:h.path,oldValue:n,object:t.proxy}])),n},unshift:function(t,o){const n=Array.from(arguments);let s;n.splice(0,2),n.forEach((e,t)=>{n[t]=b(e,t,o)});const p=Reflect.apply(t.unshift,t,n);for(let e,o=0,n=t.length;o<n;o++)if((e=t[o])&&"object"==typeof e){const t=e[r];t&&(t.ownKey=o)}const a=f(o);if(a.observers.length){const r=n.length;let p;s=new Array(r);for(let n=0;n<r;n++)(p=a.path.slice(0)).push(n),s[n]={type:e,path:p,value:t[n],object:o.proxy};i(a.observers,s)}return p},reverse:function(e,t){let o,n,s,p;for(e.reverse(),o=0,n=e.length;o<n;o++)if((s=e[o])&&"object"==typeof s){const e=s[r];e&&(e.ownKey=o)}const a=f(t);return a.observers.length&&(p=[{type:"reverse",path:a.path,object:t.proxy}],i(a.observers,p)),t.proxy},sort:function(e,t,o){let n,s,p,a;for(e.sort(o),n=0,s=e.length;n<s;n++)if((p=e[n])&&"object"==typeof p){const e=p[r];e&&(e.ownKey=n)}const c=f(t);return c.observers.length&&(a=[{type:"shuffle",path:c.path,object:t.proxy}],i(c.observers,a)),t.proxy},fill:function(o,n){const s=f(n),p=[],a=o.length,c=Array.from(arguments);c.splice(0,2);const h=c.length,l=h<2?0:c[1]<0?a+c[1]:c[1],u=h<3?a:c[2]<0?a+c[2]:c[2],y=o.slice(0);let v,g;Reflect.apply(o.fill,o,c);for(let a,c,h=l;h<u;h++)a=o[h],o[h]=b(a,h,n),y.hasOwnProperty(h)?((c=y[h])&&"object"==typeof c&&(v=c[r])&&(c=v.detach()),(g=s.path.slice(0)).push(h),p.push({type:t,path:g,value:o[h],oldValue:c,object:n.proxy})):((g=s.path.slice(0)).push(h),p.push({type:e,path:g,value:o[h],object:n.proxy}));return s.observers.length&&i(s.observers,p),n.proxy},splice:function(n,s){const p=f(s),a=[],c=Array.from(arguments),h=n.length;c.splice(0,2);const l=c.length;for(let e,t=2;t<l;t++)e=c[t],c[t]=b(e,t,s);const u=0===l?0:c[0]<0?h+c[0]:c[0],y=l<2?h-u:c[1],v=Math.max(l-2,0),g=Reflect.apply(n.splice,n,c),d=n.length;let j,w,x,m;for(let e,t=0;t<d;t++)(e=n[t])&&"object"==typeof e&&(j=e[r])&&(j.ownKey=t);for(w=0,x=g.length;w<x;w++)(m=g[w])&&"object"==typeof m&&(j=m[r])&&(g[w]=j.detach());if(p.observers.length){let r,c;for(r=0;r<y;r++)(c=p.path.slice(0)).push(u+r),r<v?a.push({type:t,path:c,value:n[u+r],oldValue:g[r],object:s.proxy}):a.push({type:o,path:c,oldValue:g[r],object:s.proxy});for(;r<v;r++)(c=p.path.slice(0)).push(u+r),a.push({type:e,path:c,value:n[u+r],object:s.proxy});i(p.observers,a)}return g}};class y{constructor(e,t){const o=e.target,r=e.parent,n=e.ownKey;let s;r&&void 0!==n?(this.parent=r,this.ownKey=n,s=c):(this.isRevoked=!1,this.observers=[],s=a);const p=t(o,s,this);this.revokable=Proxy.revocable(p,this),this.proxy=this.revokable.proxy,this.target=p}set(o,n,s){let p,a=o[n];if(s===a)return!0;const c=b(s,n,this);if(o[n]=c,a&&"object"==typeof a){const e=a[r];e&&(a=e.detach())}const h=f(this);return h.observers.length&&(h.path.push(n),p=void 0===a?[{type:e,path:h.path,value:c,object:this.proxy}]:[{type:t,path:h.path,value:c,oldValue:a,object:this.proxy}],i(h.observers,p)),!0}deleteProperty(e,t){let n,s=e[t];if(delete e[t],s&&"object"==typeof s){const e=s[r];e&&(s=e.detach())}const p=f(this);return p.observers.length&&(p.path.push(t),n=[{type:o,path:p.path,oldValue:s,object:this.proxy}],i(p.observers,n)),!0}}class v extends y{constructor(e){super(e,h)}detach(){const e=this.target;let t,o,n=e.length;for(;n--;)(t=e[n])&&"object"==typeof t&&(o=t[r])&&(e[n]=o.detach());return e}get(e,t){return u.hasOwnProperty(t)?u[t].bind(void 0,e,this):e[t]}}class g extends y{constructor(e){super(e,l)}detach(){const e=this.target,t=Object.keys(e);let o,n,s,p=t.length;for(;p--;)(n=e[o=t[p]])&&"object"==typeof n&&(s=n[r])&&(e[o]=s.detach());return e}}class d{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(e){if(e&&"object"==typeof e){if(e[r])return e;if(Array.isArray(e))return new v({target:e,ownKey:null,parent:null}).proxy;if(e instanceof Date||e instanceof Blob||e instanceof Error)throw new Error(`${e} found to be one of non-observable types`);return new g({target:e,ownKey:null,parent:null}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")}static isObservable(e){return!(!e||!e[r])}}Object.freeze(d),exports.Observable=d;