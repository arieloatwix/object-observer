const e="insert",t="update",o="delete",r="reverse",s="shuffle",n=Symbol("system-observer-key"),p=["path","pathsFrom"],a=function(e){const t={};e.path&&"string"!=typeof e.path?console.error('"path" option, if/when provided, MUST be a non-empty string'):t.path=e.path,e.pathsFrom&&(e.path?console.error('"pathsFrom" option MAY NOT be specified together with "path" option'):"string"!=typeof e.pathsFrom?console.error('"pathsFrom" option, if/when provided, MUST be a non-empty string'):t.pathsFrom=e.pathsFrom);const o=Object.keys(e).filter(e=>p.indexOf(e)<0);return o.length&&console.error(`'${o.join(", ")}' is/are not a valid option/s`),t},l=function(){const e=this[n];let t;if((t=e.parent?u(e).observers:e.observers).size){let e=arguments.length;if(e)for(;e;)t.delete(arguments[--e]);else t.clear()}},c={revoke:{value:function(){this[n].revoke()}},observe:{value:function(e,t){if("function"!=typeof e)throw new Error("observer parameter MUST be a function");const o=this[n].observers;if(o.has(e))console.info("observer may be bound to an observable only once");else{let r;r=t?a(t):{},o.set(e,r)}}},unobserve:{value:l}},i={observe:{value:function(e,t){if("function"!=typeof e)throw new Error("observer parameter MUST be a function");const o=this[n],r=u(o),s=r.path.join("."),p=r.observers;if(p.has(e))console.info("observer may be bound to an observable only once");else{let o;(o=t?a(t):{}).path?o.path=s+"."+o.path:o.pathsFrom=s+"."+(o.pathsFrom?o.pathsFrom:""),p.set(e,o)}}},unobserve:{value:l}},h=function(e,t){let o,r=e.length;const s=new Array(r);for(Object.defineProperty(s,n,{value:t});r;)o=e[--r],s[r]=o&&"object"==typeof o?y(o,r,t):o;return s},f=function(e,t){const o=Object.keys(e),r={};Object.defineProperty(r,n,{value:t});let s,p,a=o.length;for(;a;)p=e[s=o[--a]],r[s]=p&&"object"==typeof p?y(p,s,t):p;return r},b=function(e,t){let o,r,s,n,p;for(o of e.keys())try{r=e.get(o),s=t,r.path?(n=r.path,s=t.filter(e=>e.path.join(".")===n)):r.pathsFrom&&(p=r.pathsFrom,s=t.filter(e=>e.path.join(".").startsWith(p))),s.length&&o(s)}catch(e){console.error(`failed to deliver changes to listener ${o}`,e)}},u=function(e){const t=[];let o=0,r=0;for(;e.parent;)t[o++]=e.ownKey,e=e.parent;const s=new Array(o);for(;o;)s[r++]=t[--o];return{observers:e.observers,path:s}},y=function(e,t,o){return e&&"object"==typeof e?Array.isArray(e)?new j({target:e,ownKey:t,parent:o}).proxy:e instanceof Date||e instanceof Blob||e instanceof Error?e:new g({target:e,ownKey:t,parent:o}).proxy:e};class v{constructor(e,t){const o=t(e.target,this);null===e.parent?(this.isRevoked=!1,Object.defineProperty(this,"observers",{value:new Map}),Object.defineProperties(o,c)):(this.parent=e.parent,this.ownKey=e.ownKey,Object.defineProperties(o,i)),this.revokable=Proxy.revocable(o,this),this.proxy=this.revokable.proxy,this.target=o}set(o,r,s){let p,a=o[r];if(s===a)return!0;const l=y(s,r,this);if(o[r]=l,a&&"object"==typeof a){const e=a[n];e&&(a=e.revoke())}const c=u(this);return c.observers.size&&(c.path.push(r),p=void 0===a?[{type:e,path:c.path,value:l,object:this.proxy}]:[{type:t,path:c.path,value:l,oldValue:a,object:this.proxy}],b(c.observers,p)),!0}deleteProperty(e,t){let r,s=e[t];if(delete e[t],s&&"object"==typeof s){const e=s[n];e&&(s=e.revoke())}const p=u(this);return p.observers.size&&(p.path.push(t),r=[{type:o,path:p.path,oldValue:s,object:this.proxy}],b(p.observers,r)),!0}}class j extends v{constructor(e){super(e,h)}revoke(){this.revokable.revoke();const e=this.target;let t,o,r=e.length;for(;r;)(t=e[--r])&&"object"==typeof t&&(o=t[n])&&(e[r]=o.revoke());return e}get(p,a){const l={pop:function(e,t){const r=e.length-1;let s=e.pop();if(s&&"object"==typeof s){const e=s[n];e&&(s=e.revoke())}const p=u(t);return p.observers.size&&(p.path.push(r),b(p.observers,[{type:o,path:p.path,oldValue:s,object:t.proxy}])),s},push:function(t,o){let r,s,n,p,a=arguments.length-2;const l=new Array(a),c=t.length;for(r=0;r<a;r++)s=arguments[r+2],l[r]=y(s,c+r,o);const i=Reflect.apply(t.push,t,l),h=u(o);if(h.observers.size){for(n=[],r=c,a=t.length;r<a;r++)(p=h.path.slice(0)).push(r),n[r-c]={type:e,path:p,value:t[r],object:o.proxy};b(h.observers,n)}return i},shift:function(e,t){let r,s,p,a,l,c;for((r=e.shift())&&"object"==typeof r&&(c=r[n])&&(r=c.revoke()),s=0,p=e.length;s<p;s++)(a=e[s])&&"object"==typeof a&&(c=a[n])&&(c.ownKey=s);const i=u(t);return i.observers.size&&(i.path.push(0),l=[{type:o,path:i.path,oldValue:r,object:t.proxy}],b(i.observers,l)),r},unshift:function(t,o){const r=Array.from(arguments);let s;r.splice(0,2),r.forEach((e,t)=>{r[t]=y(e,t,o)});const p=Reflect.apply(t.unshift,t,r);for(let e,o=0,r=t.length;o<r;o++)if((e=t[o])&&"object"==typeof e){const t=e[n];t&&(t.ownKey=o)}const a=u(o);if(a.observers.size){const n=r.length;let p;s=new Array(n);for(let r=0;r<n;r++)(p=a.path.slice(0)).push(r),s[r]={type:e,path:p,value:t[r],object:o.proxy};b(a.observers,s)}return p},reverse:function(e,t){let o,s,p,a;for(e.reverse(),o=0,s=e.length;o<s;o++)if((p=e[o])&&"object"==typeof p){const e=p[n];e&&(e.ownKey=o)}const l=u(t);return l.observers.size&&(a=[{type:r,path:l.path,object:t.proxy}],b(l.observers,a)),t.proxy},sort:function(e,t,o){let r,p,a,l;for(e.sort(o),r=0,p=e.length;r<p;r++)if((a=e[r])&&"object"==typeof a){const e=a[n];e&&(e.ownKey=r)}const c=u(t);return c.observers.size&&(l=[{type:s,path:c.path,object:t.proxy}],b(c.observers,l)),t.proxy},fill:function(o,r){const s=u(r),p=[],a=o.length,l=Array.from(arguments);l.splice(0,2);const c=l.length,i=c<2?0:l[1]<0?a+l[1]:l[1],h=c<3?a:l[2]<0?a+l[2]:l[2],f=o.slice(0);let v,j;Reflect.apply(o.fill,o,l);for(let a,l,c=i;c<h;c++)a=o[c],o[c]=y(a,c,r),f.hasOwnProperty(c)?((l=f[c])&&"object"==typeof l&&(v=l[n])&&(l=v.revoke()),(j=s.path.slice(0)).push(c),p.push({type:t,path:j,value:o[c],oldValue:l,object:r.proxy})):((j=s.path.slice(0)).push(c),p.push({type:e,path:j,value:o[c],object:r.proxy}));return s.observers.size&&b(s.observers,p),r.proxy},splice:function(r,s){const p=u(s),a=[],l=Array.from(arguments),c=r.length;l.splice(0,2);const i=l.length;for(let e,t=2;t<i;t++)e=l[t],l[t]=y(e,t,s);const h=0===i?0:l[0]<0?c+l[0]:l[0],f=i<2?c-h:l[1],v=Math.max(i-2,0),j=Reflect.apply(r.splice,r,l),g=r.length;let d,w,x,m;for(let e,t=0;t<g;t++)(e=r[t])&&"object"==typeof e&&(d=e[n])&&(d.ownKey=t);for(w=0,x=j.length;w<x;w++)(m=j[w])&&"object"==typeof m&&(d=m[n])&&(j[w]=d.revoke());if(p.observers.size){let n,l;for(n=0;n<f;n++)(l=p.path.slice(0)).push(h+n),n<v?a.push({type:t,path:l,value:r[h+n],oldValue:j[n],object:s.proxy}):a.push({type:o,path:l,oldValue:j[n],object:s.proxy});for(;n<v;n++)(l=p.path.slice(0)).push(h+n),a.push({type:e,path:l,value:r[h+n],object:s.proxy});b(p.observers,a)}return j}};return l.hasOwnProperty(a)?l[a].bind(void 0,p,this):p[a]}}class g extends v{constructor(e){super(e,f)}revoke(){this.revokable.revoke();const e=this.target,t=Object.keys(e);let o,r,s,p=t.length;for(;p;)(r=e[o=t[--p]])&&"object"==typeof r&&(s=r[n])&&(e[o]=s.revoke());return e}}class d{constructor(){throw new Error('Observable MAY NOT be created via constructor, see "Observable.from" API')}static from(e){if(e&&"object"==typeof e){if(e[n])return e;if(Array.isArray(e))return new j({target:e,ownKey:null,parent:null}).proxy;if(e instanceof Date||e instanceof Blob||e instanceof Error)throw new Error(`${e} found to be one of non-observable types`);return new g({target:e,ownKey:null,parent:null}).proxy}throw new Error("observable MAY ONLY be created from a non-null object")}static isObservable(e){return!(!e||!e[n])}}Object.freeze(d),exports.Observable=d;